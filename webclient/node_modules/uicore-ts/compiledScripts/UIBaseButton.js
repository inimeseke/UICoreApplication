var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var UIBaseButton_exports = {};
__export(UIBaseButton_exports, {
  UIBaseButton: () => UIBaseButton
});
module.exports = __toCommonJS(UIBaseButton_exports);
var import_UIColor = require("./UIColor");
var import_UIObject = require("./UIObject");
var import_UIView = require("./UIView");
class UIBaseButton extends import_UIView.UIView {
  constructor(elementID, elementType, initViewData) {
    super(elementID, import_UIObject.nil, elementType, initViewData);
    this._selected = import_UIObject.NO;
    this._highlighted = import_UIObject.NO;
    this._isToggleable = import_UIObject.NO;
    this.initViewStateControl();
  }
  initViewStateControl() {
    this.class.superclass = import_UIView.UIView;
    this._isPointerInside = import_UIObject.NO;
    const setHovered = function() {
      this.hovered = import_UIObject.YES;
    }.bind(this);
    this.addTargetForControlEvent(import_UIView.UIView.controlEvent.PointerHover, setHovered);
    const setNotHovered = function() {
      this.hovered = import_UIObject.NO;
    }.bind(this);
    this.addTargetForControlEvents([
      import_UIView.UIView.controlEvent.PointerLeave,
      import_UIView.UIView.controlEvent.PointerCancel,
      import_UIView.UIView.controlEvent.MultipleTouches
    ], setNotHovered);
    var highlightingTime;
    const setHighlighted = function() {
      this.highlighted = import_UIObject.YES;
      highlightingTime = Date.now();
    }.bind(this);
    this.addTargetForControlEvent(import_UIView.UIView.controlEvent.PointerDown, setHighlighted);
    this.addTargetForControlEvent(import_UIView.UIView.controlEvent.PointerEnter, setHighlighted);
    const setNotHighlighted = function() {
      this.highlighted = import_UIObject.NO;
    }.bind(this);
    const setNotHighlightedWithMinimumDuration = function() {
      const minimumDurationInMilliseconds = 50;
      const elapsedTime = Date.now() - highlightingTime;
      if (minimumDurationInMilliseconds < elapsedTime) {
        this.highlighted = import_UIObject.NO;
      } else {
        setTimeout(function() {
          this.highlighted = import_UIObject.NO;
        }.bind(this), minimumDurationInMilliseconds - elapsedTime);
      }
    }.bind(this);
    this.addTargetForControlEvents([
      import_UIView.UIView.controlEvent.PointerLeave,
      import_UIView.UIView.controlEvent.PointerCancel,
      import_UIView.UIView.controlEvent.MultipleTouches
    ], setNotHighlighted);
    this.addTargetForControlEvent(import_UIView.UIView.controlEvent.PointerUp, setNotHighlightedWithMinimumDuration);
    this.addTargetForControlEvent(import_UIView.UIView.controlEvent.EnterDown, function() {
      setHighlighted();
      setNotHighlightedWithMinimumDuration();
    });
    this.addTargetForControlEvent(
      import_UIView.UIView.controlEvent.Focus,
      function(sender, event) {
        this.focused = import_UIObject.YES;
      }.bind(this)
    );
    this.addTargetForControlEvent(
      import_UIView.UIView.controlEvent.Blur,
      function(sender, event) {
        this.focused = import_UIObject.NO;
      }.bind(this)
    );
    this.updateContentForCurrentState();
    this.pausesPointerEvents = import_UIObject.YES;
    this.tabIndex = 1;
    this.style.cursor = "pointer";
    this.nativeSelectionEnabled = import_UIObject.NO;
    this.addTargetForControlEvents([
      import_UIView.UIView.controlEvent.EnterDown,
      import_UIView.UIView.controlEvent.PointerUpInside
    ], function(sender, event) {
      if (this.isToggleable) {
        this.toggleSelectedState();
      }
    }.bind(this));
  }
  set hovered(hovered) {
    this._hovered = hovered;
    this.updateContentForCurrentState();
  }
  get hovered() {
    return this._hovered;
  }
  set highlighted(highlighted) {
    this._highlighted = highlighted;
    this.updateContentForCurrentState();
  }
  get highlighted() {
    return this._highlighted;
  }
  set focused(focused) {
    this._focused = focused;
    if (focused) {
      this.focus();
    } else {
      this.blur();
    }
    this.updateContentForCurrentState();
  }
  get focused() {
    return this._focused;
  }
  set selected(selected) {
    this._selected = selected;
    this.updateContentForCurrentState();
  }
  get selected() {
    return this._selected;
  }
  updateContentForCurrentState() {
    var updateFunction = this.updateContentForNormalState;
    if (this.selected && this.highlighted) {
      updateFunction = this.updateContentForSelectedAndHighlightedState;
    } else if (this.selected) {
      updateFunction = this.updateContentForSelectedState;
    } else if (this.focused) {
      updateFunction = this.updateContentForFocusedState;
    } else if (this.highlighted) {
      updateFunction = this.updateContentForHighlightedState;
    } else if (this.hovered) {
      updateFunction = this.updateContentForHoveredState;
    }
    if (!(0, import_UIObject.IS)(updateFunction)) {
      this.backgroundColor = import_UIColor.UIColor.nilColor;
    } else {
      updateFunction.call(this);
    }
  }
  updateContentForNormalState() {
  }
  updateContentForHoveredState() {
    this.updateContentForNormalState();
  }
  updateContentForFocusedState() {
    this.updateContentForHoveredState();
  }
  updateContentForHighlightedState() {
  }
  updateContentForSelectedState() {
  }
  updateContentForSelectedAndHighlightedState() {
    this.updateContentForSelectedState();
  }
  set enabled(enabled) {
    super.enabled = enabled;
    this.updateContentForCurrentEnabledState();
  }
  get enabled() {
    return super.enabled;
  }
  updateContentForCurrentEnabledState() {
    if (this.enabled) {
      this.alpha = 1;
    } else {
      this.alpha = 0.5;
    }
    this.userInteractionEnabled = this.enabled;
  }
  addStyleClass(styleClassName) {
    super.addStyleClass(styleClassName);
    if (this.styleClassName != styleClassName) {
      this.updateContentForCurrentState.call(this);
    }
  }
  didReceiveBroadcastEvent(event) {
    super.didReceiveBroadcastEvent(event);
    if (event.name == import_UIView.UIView.broadcastEventName.PageDidScroll || event.name == import_UIView.UIView.broadcastEventName.AddedToViewTree) {
      this.hovered = import_UIObject.NO;
      this.highlighted = import_UIObject.NO;
    }
  }
  toggleSelectedState() {
    this.selected = !this.selected;
  }
  set isToggleable(isToggleable) {
    this._isToggleable = isToggleable;
  }
  get isToggleable() {
    return this._isToggleable;
  }
  layoutSubviews() {
    super.layoutSubviews();
    const bounds = this.bounds;
  }
  sendControlEventForKey(eventKey, nativeEvent) {
    if (eventKey == import_UIView.UIView.controlEvent.PointerUpInside && !this.highlighted) {
      const asd = 1;
    } else {
      super.sendControlEventForKey(eventKey, nativeEvent);
    }
  }
  static getEventCoordinatesInDocument(touchOrMouseEvent) {
    var posx = 0;
    var posy = 0;
    var e = touchOrMouseEvent;
    if (!e) {
      e = window.event;
    }
    if (e.pageX || e.pageY) {
      posx = e.pageX;
      posy = e.pageY;
    } else if (e.clientX || e.clientY) {
      posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    const coordinates = { "x": posx, "y": posy };
    return coordinates;
  }
  static getElementPositionInDocument(el) {
    var xPosition = 0;
    var yPosition = 0;
    while (el) {
      if (el.tagName == "BODY") {
      } else {
        xPosition += el.offsetLeft - el.scrollLeft + el.clientLeft;
        yPosition += el.offsetTop - el.scrollTop + el.clientTop;
      }
      el = el.offsetParent;
    }
    return {
      x: xPosition,
      y: yPosition
    };
  }
  static convertCoordinatesFromDocumentToElement(x, y, element) {
    const elementPositionInDocument = this.getElementPositionInDocument(element);
    const coordinatesInElement = { "x": x - elementPositionInDocument.x, "y": y - elementPositionInDocument.y };
    return coordinatesInElement;
  }
  static getEventCoordinatesInElement(touchOrMouseEvent, element) {
    const coordinatesInDocument = this.getEventCoordinatesInDocument(touchOrMouseEvent);
    const coordinatesInElement = this.convertCoordinatesFromDocumentToElement(
      coordinatesInDocument.x,
      coordinatesInDocument.y,
      element
    );
    return coordinatesInElement;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  UIBaseButton
});
//# sourceMappingURL=UIBaseButton.js.map
