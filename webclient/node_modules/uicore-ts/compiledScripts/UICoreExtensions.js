var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var UICoreExtensions_exports = {};
__export(UICoreExtensions_exports, {
  PrimitiveNumber: () => PrimitiveNumber,
  promisedProperties: () => promisedProperties
});
module.exports = __toCommonJS(UICoreExtensions_exports);
var import_UICoreExtensionValueObject = require("./UICoreExtensionValueObject");
var import_UIObject = require("./UIObject");
const YES = true;
const NO = false;
if ("removeElementAtIndex" in Array.prototype == NO) {
  Array.prototype.removeElementAtIndex = function(index) {
    if (index >= 0 && index < this.length) {
      this.splice(index, 1);
    }
  };
}
if ("removeElement" in Array.prototype == NO) {
  Array.prototype.removeElement = function(element) {
    this.removeElementAtIndex(this.indexOf(element));
  };
}
if ("insertElementAtIndex" in Array.prototype == NO) {
  Array.prototype.insertElementAtIndex = function(index, element) {
    if (index >= 0 && index <= this.length) {
      this.splice(index, 0, element);
    }
  };
}
if ("replaceElementAtIndex" in Array.prototype == NO) {
  Array.prototype.replaceElementAtIndex = function(index, element) {
    this.removeElementAtIndex(index);
    this.insertElementAtIndex(index, element);
  };
}
if ("contains" in Array.prototype == NO) {
  Array.prototype.contains = function(element) {
    const result = this.indexOf(element) != -1;
    return result;
  };
}
if ("containsAny" in Array.prototype == NO) {
  Array.prototype.containsAny = function(elements) {
    const result = this.anyMatch(function(element, index, array) {
      return elements.contains(element);
    });
    return result;
  };
}
if ("anyMatch" in Array.prototype == NO) {
  Array.prototype.anyMatch = function(functionToCall) {
    const result = this.findIndex(functionToCall) > -1;
    return result;
  };
}
if ("noneMatch" in Array.prototype == NO) {
  Array.prototype.noneMatch = function(functionToCall) {
    const result = this.findIndex(functionToCall) == -1;
    return result;
  };
}
if ("allMatch" in Array.prototype == NO) {
  Array.prototype.allMatch = function(functionToCall) {
    function reversedFunction(value, index, array) {
      return !functionToCall(value, index, array);
    }
    const result = this.findIndex(reversedFunction) == -1;
    return result;
  };
}
if ("findAsyncSequential" in Array.prototype == NO) {
  Array.prototype.findAsyncSequential = function(functionToCall) {
    function findAsyncSequential(array, predicate) {
      return __async(this, null, function* () {
        for (const t of array) {
          if (yield predicate(t)) {
            return t;
          }
        }
        return void 0;
      });
    }
    const result = findAsyncSequential(this, functionToCall);
    return result;
  };
}
if ("groupedBy" in Array.prototype == NO) {
  Array.prototype.groupedBy = function(funcProp) {
    return this.reduce(function(acc, val) {
      (acc[funcProp(val)] = acc[funcProp(val)] || []).push(val);
      return acc;
    }, {});
  };
}
if ("firstElement" in Array.prototype == NO) {
  Object.defineProperty(Array.prototype, "firstElement", {
    get: function firstElement() {
      const result = this[0];
      return result;
    },
    set: function(element) {
      if (this.length == 0) {
        this.push(element);
        return;
      }
      this[0] = element;
    }
  });
}
if ("lastElement" in Array.prototype == NO) {
  Object.defineProperty(Array.prototype, "lastElement", {
    get: function lastElement() {
      const result = this[this.length - 1];
      return result;
    },
    set: function(element) {
      if (this.length == 0) {
        this.push(element);
        return;
      }
      this[this.length - 1] = element;
    }
  });
}
if ("everyElement" in Array.prototype == NO) {
  Object.defineProperty(Array.prototype, "everyElement", {
    get: function everyElement() {
      var valueKeys = [];
      const targetFunction = (objects) => {
        return this.map((element, index, array) => {
          var elementFunction = import_UIObject.UIObject.valueForKeyPath(valueKeys.join("."), element).bind(
            element,
            objects
          );
          return elementFunction();
        });
      };
      const result = new Proxy(
        targetFunction,
        {
          get: (target, key, receiver) => {
            if (key == "UI_elementValues") {
              return this.map((element, index, array) => import_UIObject.UIObject.valueForKeyPath(
                valueKeys.join("."),
                element
              ));
            }
            valueKeys.push(key);
            return result;
          },
          set: (target, key, value, receiver) => {
            valueKeys.push(key);
            this.forEach((element, index, array) => {
              import_UIObject.UIObject.setValueForKeyPath(valueKeys.join("."), value, element, YES);
            });
            return true;
          }
        }
      );
      return result;
    },
    set: function(element) {
      for (var i = 0; i < this.length; ++i) {
        this[i] = element;
      }
    }
  });
}
if ("copy" in Array.prototype == NO) {
  Array.prototype.copy = function() {
    const result = this.slice(0);
    return result;
  };
}
if ("arrayByRepeating" in Array.prototype == NO) {
  Array.prototype.arrayByRepeating = function(numberOfRepetitions) {
    const result = [];
    for (var i = 0; i < numberOfRepetitions; i++) {
      this.forEach(function(element, index, array) {
        result.push(element);
      });
    }
    return result;
  };
}
if ("arrayByTrimmingToLengthIfLonger" in Array.prototype == NO) {
  Array.prototype.arrayByTrimmingToLengthIfLonger = function(maxLength) {
    const result = [];
    for (var i = 0; i < maxLength && i < this.length; i++) {
      result.push(this[i]);
    }
    return result;
  };
}
if ("summedValue" in Array.prototype == NO) {
  Object.defineProperty(Array.prototype, "summedValue", {
    get: function summedValue() {
      const result = this.reduce(function(a, b) {
        return a + b;
      }, 0);
      return result;
    }
  });
}
Array.prototype.max = function() {
  return Math.max.apply(null, this);
};
Array.prototype.min = function() {
  return Math.min.apply(null, this);
};
if ("isEqualToArray" in Array.prototype == YES) {
  console.warn(
    "Overriding existing Array.prototype.isEqualToArray. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code."
  );
}
Array.prototype.isEqualToArray = function(array, keyPath) {
  if (!array) {
    return false;
  }
  if (this.length != array.length) {
    return false;
  }
  var i = 0;
  const l = this.length;
  for (; i < l; i++) {
    if (this[i] instanceof Array && array[i] instanceof Array && !keyPath) {
      if (!this[i].isEqualToArray(array[i])) {
        return false;
      }
    } else if (keyPath && import_UIObject.UIObject.valueForKeyPath(keyPath, this[i]) != import_UIObject.UIObject.valueForKeyPath(keyPath, array[i])) {
      return false;
    } else if (this[i] != array[i]) {
      return false;
    }
  }
  return true;
};
Object.defineProperty(Array.prototype, "isEqualToArray", { enumerable: false });
if ("forEach" in Object.prototype == NO) {
  Object.prototype.forEach = function(callbackFunction) {
    const keys = Object.keys(this);
    keys.forEach(function(key, index, array) {
      callbackFunction(this[key], key);
    }.bind(this));
  };
  Object.defineProperty(Object.prototype, "forEach", { enumerable: false });
}
if ("allValues" in Object.prototype == NO) {
  Object.defineProperty(Object.prototype, "allValues", {
    get: function() {
      const values = [];
      this.forEach(function(value) {
        values.push(value);
      });
      return values;
    }
  });
}
if ("allKeys" in Object.prototype == NO) {
  Object.defineProperty(Object.prototype, "allKeys", {
    get: function() {
      const values = Object.keys(this);
      return values;
    }
  });
}
if ("objectByCopyingValuesRecursivelyFromObject" in Object.prototype == NO) {
  Object.prototype.objectByCopyingValuesRecursivelyFromObject = function(object) {
    function isAnObject(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
    function mergeRecursively(target, source) {
      const output = Object.assign({}, target);
      if (isAnObject(target) && isAnObject(source)) {
        Object.keys(source).forEach(function(key) {
          if (isAnObject(source[key])) {
            output[key] = mergeRecursively(target[key], source[key]);
          } else {
            Object.assign(output, { [key]: source[key] });
          }
        });
      }
      return output;
    }
    const result = mergeRecursively(this, object);
    return result;
  };
  Object.defineProperty(Object.prototype, "objectByCopyingValuesRecursivelyFromObject", { enumerable: false });
}
if ("asValueObject" in Object.prototype == NO) {
  Object.prototype.asValueObject = function() {
    const result = new import_UICoreExtensionValueObject.UICoreExtensionValueObject(this);
    return result;
  };
  Object.defineProperty(Object.prototype, "asValueObject", { enumerable: false });
}
function promisedProperties(object) {
  let promisedProperties2 = [];
  const objectKeys = Object.keys(object);
  objectKeys.forEach((key) => promisedProperties2.push(object[key]));
  return Promise.all(promisedProperties2).then((resolvedValues) => {
    return resolvedValues.reduce((resolvedObject, property, index) => {
      resolvedObject[objectKeys[index]] = property;
      return resolvedObject;
    }, object);
  });
}
if ("contains" in String.prototype == NO) {
  String.prototype.contains = function(string) {
    const result = this.indexOf(string) != -1;
    return result;
  };
  Object.defineProperty(Object.prototype, "contains", { enumerable: false });
}
if ("capitalizedString" in String.prototype == NO) {
  Object.defineProperty(Object.prototype, "capitalizedString", {
    get: function() {
      const result = this.charAt(0).toUpperCase() + this.slice(1).toLowerCase();
      return result;
    }
  });
}
if ("numericalValue" in String.prototype == NO) {
  Object.defineProperty(String.prototype, "numericalValue", {
    get: function numericalValue() {
      const result = Number(this);
      return result;
    }
  });
}
if ("isAString" in String.prototype == NO) {
  String.prototype.isAString = YES;
}
if ("isANumber" in Number.prototype == NO) {
  Number.prototype.isANumber = YES;
}
if ("integerValue" in Number.prototype == NO) {
  Object.defineProperty(Number.prototype, "integerValue", {
    get: function() {
      const result = parseInt("" + (Math.round(this) + 0.5));
      return result;
    }
  });
}
class PrimitiveNumber {
  static [Symbol.hasInstance](x) {
    return;
  }
}
if ("integerValue" in Boolean.prototype == NO) {
  Object.defineProperty(Boolean.prototype, "integerValue", {
    get: function() {
      if (this == true) {
        return 1;
      }
      return 0;
    }
  });
}
if ("dateString" in Date.prototype == NO) {
  Object.defineProperty(Date.prototype, "dateString", {
    get: function dateString() {
      const result = ("0" + this.getDate()).slice(-2) + "-" + ("0" + (this.getMonth() + 1)).slice(-2) + "-" + this.getFullYear() + " " + ("0" + this.getHours()).slice(-2) + ":" + ("0" + this.getMinutes()).slice(-2);
      return result;
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PrimitiveNumber,
  promisedProperties
});
//# sourceMappingURL=UICoreExtensions.js.map
