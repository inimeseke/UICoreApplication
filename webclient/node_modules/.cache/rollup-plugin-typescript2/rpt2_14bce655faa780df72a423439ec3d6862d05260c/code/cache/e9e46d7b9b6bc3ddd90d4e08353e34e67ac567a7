{"code":"import { FIRST, IS, IS_NOT, nil, NO, UIObject, YES } from \"uicore-ts\";\r\nimport { CBSocketClient } from \"./CBSocketClient\";\r\nexport class CBSocketCallbackHolder extends UIObject {\r\n    constructor(socketClient, previousCallbackHolder) {\r\n        super();\r\n        this.messageDescriptors = {};\r\n        this.handlers = {};\r\n        this.onetimeHandlers = {};\r\n        this.keysForIdentifiers = {};\r\n        this.isValid = YES;\r\n        this._verifiedResponseHashesDictionary = {};\r\n        this._socketClient = socketClient;\r\n        if (IS(previousCallbackHolder)) {\r\n            this.handlers = previousCallbackHolder.handlers;\r\n            this._verifiedResponseHashesDictionary = previousCallbackHolder._verifiedResponseHashesDictionary;\r\n        }\r\n    }\r\n    triggerDisconnectHandlers() {\r\n        this.messageDescriptors.forEach(function (descriptor, key) {\r\n            if (descriptor.mainResponseReceived) {\r\n                descriptor.completionFunction(CBSocketClient.disconnectionMessage, nil);\r\n            }\r\n        });\r\n    }\r\n    registerHandler(key, handlerFunction) {\r\n        if (!this.handlers[key]) {\r\n            this.handlers[key] = [];\r\n        }\r\n        this.handlers[key].push(handlerFunction);\r\n    }\r\n    registerOnetimeHandler(key, handlerFunction) {\r\n        if (!this.onetimeHandlers[key]) {\r\n            this.onetimeHandlers[key] = [];\r\n        }\r\n        this.onetimeHandlers[key].push(handlerFunction);\r\n    }\r\n    get storedResponseHashesDictionary() {\r\n        if (IS_NOT(this._storedResponseHashesDictionary)) {\r\n            this._storedResponseHashesDictionary = JSON.parse(localStorage[\"CBSocketResponseHashesDictionary\"] || \"{}\");\r\n        }\r\n        return this._storedResponseHashesDictionary;\r\n    }\r\n    storedResponseHashObjectForKey(requestKey, requestDataHash) {\r\n        const localStorageKey = this.keyForRequestKeyAndRequestDataHash(requestKey, requestDataHash);\r\n        const hashObject = this.storedResponseHashesDictionary[localStorageKey];\r\n        const result = FIRST(hashObject, {});\r\n        return result;\r\n    }\r\n    storedResponseForKey(requestKey, requestDataHash) {\r\n        const localStorageKey = this.keyForRequestKeyAndRequestDataHash(requestKey, requestDataHash);\r\n        const storedObject = JSON.parse(localStorage[localStorageKey] || \"{}\");\r\n        return storedObject.responseMessageData;\r\n    }\r\n    keyForRequestKeyAndRequestDataHash(requestKey, requestDataHash) {\r\n        const result = \"_CBSCH_LS_key_\" + requestKey + \"_\" + requestDataHash;\r\n        return result;\r\n    }\r\n    storeResponse(requestKey, requestDataHash, responseMessage, responseDataHash) {\r\n        if (!responseMessage.canBeStoredAsResponse ||\r\n            (IS_NOT(responseMessage.messageData) && IS_NOT(responseMessage.messageDataHash))) {\r\n            return;\r\n        }\r\n        const localStorageKey = this.keyForRequestKeyAndRequestDataHash(requestKey, requestDataHash);\r\n        var validityDate;\r\n        if (responseMessage.responseValidityDuration) {\r\n            validityDate = Date.now() + responseMessage.responseValidityDuration;\r\n        }\r\n        const storedResponseHashesDictionary = this.storedResponseHashesDictionary;\r\n        storedResponseHashesDictionary[localStorageKey] = {\r\n            hash: responseDataHash,\r\n            validityDate: validityDate\r\n        };\r\n        this.saveInLocalStorage(localStorageKey, {\r\n            responseMessageData: responseMessage.messageData,\r\n            responseHash: responseDataHash\r\n        });\r\n        this.saveStoredResponseHashesDictionary(storedResponseHashesDictionary);\r\n    }\r\n    saveStoredResponseHashesDictionary(storedResponseHashesDictionary) {\r\n        this.saveInLocalStorage(\"CBSocketResponseHashesDictionary\", storedResponseHashesDictionary);\r\n    }\r\n    saveInLocalStorage(key, object) {\r\n        const stringToSave = JSON.stringify(object);\r\n        if (stringToSave != localStorage[key]) {\r\n            localStorage[key] = stringToSave;\r\n        }\r\n    }\r\n    socketShouldSendMessage(key, message, completionPolicy, completionFunction) {\r\n        var result = YES;\r\n        var triggerStoredResponseImmediately = NO;\r\n        const messageDataHash = objectHash(message.messageData || nil);\r\n        const descriptorKey = \"socketMessageDescriptor_\" + key + messageDataHash;\r\n        this.messageDescriptors[descriptorKey] = (this.messageDescriptors[descriptorKey] || []);\r\n        const hashObject = this.storedResponseHashObjectForKey(key, messageDataHash);\r\n        message.storedResponseHash = hashObject.hash;\r\n        if (completionPolicy == CBSocketClient.completionPolicy.first) {\r\n            const descriptorsForKey = (this.messageDescriptors[descriptorKey] || []);\r\n            const matchingDescriptor = descriptorsForKey.find(function (descriptor, index, array) {\r\n                return (descriptor.messageDataHash == messageDataHash);\r\n            });\r\n            if (matchingDescriptor) {\r\n                result = NO;\r\n            }\r\n        }\r\n        if (completionPolicy == CBSocketClient.completionPolicy.storedOrFirst) {\r\n            const descriptorsForKey = (this.messageDescriptors[descriptorKey] || []);\r\n            const matchingDescriptor = descriptorsForKey.find(function (descriptor, index, array) {\r\n                return (descriptor.messageDataHash == messageDataHash);\r\n            });\r\n            const storedResponse = IS(message.storedResponseHash);\r\n            if (matchingDescriptor ||\r\n                (storedResponse && this._verifiedResponseHashesDictionary[message.storedResponseHash])) {\r\n                result = NO;\r\n                triggerStoredResponseImmediately = YES;\r\n            }\r\n        }\r\n        if (completionPolicy == CBSocketClient.completionPolicy.firstOnly) {\r\n            const descriptorsForKey = (this.messageDescriptors[descriptorKey] || []);\r\n            const matchingDescriptor = descriptorsForKey.find(function (descriptor, index, array) {\r\n                return (descriptor.messageDataHash == messageDataHash);\r\n            });\r\n            if (matchingDescriptor) {\r\n                return NO;\r\n            }\r\n        }\r\n        if (hashObject && hashObject.hash && hashObject.validityDate && message.storedResponseHash &&\r\n            this._verifiedResponseHashesDictionary[message.storedResponseHash] && hashObject.validityDate >\r\n            Date.now()) {\r\n            result = NO;\r\n            triggerStoredResponseImmediately = YES;\r\n        }\r\n        if (IS(completionFunction)) {\r\n            this.messageDescriptors[descriptorKey].push({\r\n                key: key,\r\n                message: {\r\n                    identifier: message.identifier,\r\n                    inResponseToIdentifier: message.inResponseToIdentifier,\r\n                    keepWaitingForResponses: message.keepWaitingForResponses\r\n                },\r\n                sentAtTime: Date.now(),\r\n                //completionTriggered: NO,\r\n                messageDataHash: messageDataHash,\r\n                mainResponseReceived: NO,\r\n                anyMainResponseReceived: NO,\r\n                completionPolicy: completionPolicy,\r\n                completionFunction: completionFunction\r\n            });\r\n            this.keysForIdentifiers[message.identifier] = descriptorKey;\r\n        }\r\n        if (triggerStoredResponseImmediately) {\r\n            this.socketDidReceiveMessageForKey(CBSocketClient.responseMessageKey, {\r\n                identifier: nil,\r\n                messageData: nil,\r\n                inResponseToIdentifier: message.identifier,\r\n                useStoredResponse: YES\r\n            }, nil);\r\n        }\r\n        return result;\r\n    }\r\n    static defaultMultipleMessagecompletionFunction(responseMessages, callcompletionFunctions) {\r\n        callcompletionFunctions();\r\n    }\r\n    socketWillSendMultipleMessage(messageToSend, completionFunction = CBSocketCallbackHolder.defaultMultipleMessagecompletionFunction) {\r\n        const key = CBSocketClient.multipleMessageKey;\r\n        const messageDataHash = objectHash(messageToSend.messageData || nil);\r\n        const descriptorKey = \"socketMessageDescriptor_\" + key + messageDataHash;\r\n        this.messageDescriptors[descriptorKey] = (this.messageDescriptors[descriptorKey] || []);\r\n        messageToSend.storedResponseHash = this.storedResponseHashObjectForKey(key, messageDataHash).hash;\r\n        this.messageDescriptors[descriptorKey].push({\r\n            key: key,\r\n            message: {\r\n                identifier: messageToSend.identifier,\r\n                inResponseToIdentifier: messageToSend.inResponseToIdentifier,\r\n                keepWaitingForResponses: messageToSend.keepWaitingForResponses\r\n            },\r\n            sentAtTime: Date.now(),\r\n            //completionTriggered: NO,\r\n            messageDataHash: messageDataHash,\r\n            mainResponseReceived: NO,\r\n            anyMainResponseReceived: NO,\r\n            completionPolicy: CBSocketClient.completionPolicy.directOnly,\r\n            completionFunction: function (responseMessage, respondWithMessage) {\r\n                completionFunction(responseMessage.map(function (messageObject, index, array) {\r\n                    return messageObject.message.messageData;\r\n                }), function () {\r\n                    //console.log(\"Received multiple message response with length of \" + responseMessage.length + \".\");\r\n                    // Call all completion functions\r\n                    responseMessage.forEach(function (messageObject, index, array) {\r\n                        this._socketClient.didReceiveMessageForKey(messageObject.key, messageObject.message);\r\n                    }.bind(this));\r\n                }.bind(this));\r\n            }.bind(this)\r\n        });\r\n        this.keysForIdentifiers[messageToSend.identifier] = descriptorKey;\r\n    }\r\n    socketDidReceiveMessageForKey(key, message, sendResponseFunction) {\r\n        if (!this.isValid) {\r\n            return;\r\n        }\r\n        // Call static handlers\r\n        if (this.handlers[key]) {\r\n            this.handlers[key].forEach(function (handler, index, array) {\r\n                handler(message.messageData, sendResponseFunction);\r\n            }.bind(this));\r\n        }\r\n        if (this.onetimeHandlers[key]) {\r\n            this.onetimeHandlers[key].forEach(function (handler, index, array) {\r\n                handler(message.messageData, sendResponseFunction);\r\n            }.bind(this));\r\n            delete this.onetimeHandlers[key];\r\n        }\r\n        // Temporary response handlers are evaluated here\r\n        if (message.inResponseToIdentifier &&\r\n            (CBSocketClient.responseMessageKey == key || CBSocketClient.multipleMessageKey == key)) {\r\n            // Find descriptors for the key of the message that is being responded to\r\n            const descriptorKey = this.keysForIdentifiers[message.inResponseToIdentifier];\r\n            const descriptorsForKey = (this.messageDescriptors[descriptorKey] || []);\r\n            // Find response data hash to check for differences\r\n            const responseDataHash = message.messageDataHash;\r\n            // Remove identifier from dictionary\r\n            if (!message.keepWaitingForResponses) {\r\n                delete this.keysForIdentifiers[message.inResponseToIdentifier];\r\n                delete this.messageDescriptors[descriptorKey];\r\n            }\r\n            // Function to call completion function\r\n            const callCompletionFunction = (descriptor, storedResponseCondition = NO) => {\r\n                var messageData = message.messageData;\r\n                if (message.useStoredResponse && storedResponseCondition) {\r\n                    messageData = this.storedResponseForKey(descriptor.key, descriptor.messageDataHash);\r\n                    const responseHash = this.storedResponseHashObjectForKey(descriptor.key, descriptor.messageDataHash).hash;\r\n                    const localStorageKey = this.keyForRequestKeyAndRequestDataHash(descriptor.key, descriptor.messageDataHash);\r\n                    if (message.responseValidityDuration && this.storedResponseHashesDictionary[localStorageKey]) {\r\n                        this.storedResponseHashesDictionary[localStorageKey].validityDate = Date.now() +\r\n                            message.responseValidityDuration;\r\n                        this.saveStoredResponseHashesDictionary(this.storedResponseHashesDictionary);\r\n                    }\r\n                    this._verifiedResponseHashesDictionary[responseHash] = YES;\r\n                    console.log(\"Using stored response.\");\r\n                }\r\n                // Call completionFunction and set response data hash\r\n                descriptor.completionFunction(messageData, sendResponseFunction);\r\n                descriptor.responseDataHash = responseDataHash;\r\n            };\r\n            descriptorsForKey.copy().forEach(function (descriptor, index, array) {\r\n                if ((descriptor.completionPolicy == CBSocketClient.completionPolicy.directOnly &&\r\n                    descriptor.message.identifier == message.inResponseToIdentifier) || descriptor.completionPolicy ==\r\n                    CBSocketClient.completionPolicy.first || descriptor.completionPolicy ==\r\n                    CBSocketClient.completionPolicy.firstOnly || descriptor.completionPolicy ==\r\n                    CBSocketClient.completionPolicy.storedOrFirst) {\r\n                    // Calling completion function and removing descriptor\r\n                    if (!message.keepWaitingForResponses) {\r\n                        this.storeResponse(descriptor.key, descriptor.messageDataHash, message, responseDataHash);\r\n                        descriptorsForKey.removeElement(descriptor);\r\n                        sendResponseFunction.respondingToMainResponse = YES;\r\n                    }\r\n                    callCompletionFunction(descriptor, !message.keepWaitingForResponses);\r\n                }\r\n                else if (descriptor.completionPolicy == CBSocketClient.completionPolicy.all) {\r\n                    // Calling completion function\r\n                    callCompletionFunction(descriptor, !message.keepWaitingForResponses);\r\n                    // Marking descriptor as having been responded to\r\n                    if (!message.keepWaitingForResponses) {\r\n                        if (message.inResponseToIdentifier == descriptor.message.identifier) {\r\n                            sendResponseFunction.respondingToMainResponse = YES;\r\n                            descriptor.mainResponseReceived = YES;\r\n                            descriptorsForKey.removeElement(descriptor);\r\n                        }\r\n                        descriptor.anyMainResponseReceived = YES;\r\n                    }\r\n                }\r\n                else if (descriptor.completionPolicy == CBSocketClient.completionPolicy.allDifferent) {\r\n                    // Calling completionFunction if messageData is different from previous\r\n                    if (descriptor.responseDataHash != responseDataHash) {\r\n                        callCompletionFunction(descriptor, !message.keepWaitingForResponses);\r\n                    }\r\n                    // Marking descriptor as having been responded to\r\n                    if (!message.keepWaitingForResponses) {\r\n                        if (message.inResponseToIdentifier == descriptor.message.identifier) {\r\n                            sendResponseFunction.respondingToMainResponse = YES;\r\n                            descriptor.mainResponseReceived = YES;\r\n                            descriptorsForKey.removeElement(descriptor);\r\n                        }\r\n                        descriptor.anyMainResponseReceived = YES;\r\n                    }\r\n                }\r\n                else if (descriptor.completionPolicy == CBSocketClient.completionPolicy.last &&\r\n                    descriptor.message.identifier == message.inResponseToIdentifier) {\r\n                    if (!message.keepWaitingForResponses) {\r\n                        // Marking descriptor as having been responded to\r\n                        descriptor.mainResponseReceived = YES;\r\n                        descriptor.anyMainResponseReceived = YES;\r\n                        sendResponseFunction.respondingToMainResponse = YES;\r\n                    }\r\n                    else {\r\n                        descriptor.completionFunction(message.messageData, sendResponseFunction);\r\n                    }\r\n                }\r\n                else if (descriptor.completionPolicy == CBSocketClient.completionPolicy.firstAndLast ||\r\n                    descriptor.completionPolicy == CBSocketClient.completionPolicy.firstAndLastIfDifferent) {\r\n                    if (!message.keepWaitingForResponses) {\r\n                        // Only calling completionFunction once as a first response call\r\n                        if (!descriptor.anyMainResponseReceived) {\r\n                            callCompletionFunction(descriptor, !message.keepWaitingForResponses);\r\n                        }\r\n                        // Marking descriptor as having been responded to\r\n                        if (descriptor.message.identifier == message.inResponseToIdentifier) {\r\n                            descriptor.mainResponseReceived = YES;\r\n                            sendResponseFunction.respondingToMainResponse = YES;\r\n                        }\r\n                        descriptor.anyMainResponseReceived = YES;\r\n                    }\r\n                    else if (descriptor.message.identifier == message.inResponseToIdentifier &&\r\n                        message.keepWaitingForResponses) {\r\n                        descriptor.completionFunction(message.messageData, sendResponseFunction);\r\n                    }\r\n                }\r\n            }.bind(this));\r\n            // Last message completion policies\r\n            const allResponsesReceived = descriptorsForKey.allMatch(function (descriptorObject, index, array) {\r\n                return descriptorObject.mainResponseReceived;\r\n            });\r\n            descriptorsForKey.copy().forEach(function (descriptor, index, array) {\r\n                if ((descriptor.completionPolicy == CBSocketClient.completionPolicy.last ||\r\n                    descriptor.completionPolicy == CBSocketClient.completionPolicy.firstAndLast) &&\r\n                    allResponsesReceived && !message.keepWaitingForResponses) {\r\n                    // Calling completionFunction\r\n                    callCompletionFunction(descriptor, !message.keepWaitingForResponses);\r\n                    // Cleaning up\r\n                    descriptorsForKey.removeElement(descriptor);\r\n                }\r\n                else if (descriptor.completionPolicy == CBSocketClient.completionPolicy.firstAndLastIfDifferent &&\r\n                    allResponsesReceived && !message.keepWaitingForResponses) {\r\n                    // Calling completionFunction if needed\r\n                    if (descriptor.responseDataHash != responseDataHash) {\r\n                        callCompletionFunction(descriptor, !message.keepWaitingForResponses);\r\n                    }\r\n                    // Cleaning up\r\n                    descriptorsForKey.removeElement(descriptor);\r\n                }\r\n            }.bind(this));\r\n        }\r\n    }\r\n}\r\n","references":["/Users/mart/UICoreApplication/webclient/node_modules/uicore-ts/compiledScripts/index.d.ts","/Users/mart/UICoreApplication/webclient/scripts/CBCore/CBDataInterfaces.ts","/Users/mart/UICoreApplication/webclient/scripts/CBCore/CBSocketClient.ts"],"dts":{"name":"/Users/mart/UICoreApplication/webclient/node_modules/.cache/rollup-plugin-typescript2/placeholder/CBCore/CBSocketCallbackHolder.d.ts","writeByteOrderMark":false,"text":"import { UIObject } from \"uicore-ts\";\r\nimport { CBSocketMessage, CBSocketMessageCompletionFunction, CBSocketMessageHandlerFunction, CBSocketMessageSendResponseFunction, CBSocketMultipleMessage, CBSocketMultipleMessagecompletionFunction } from \"./CBDataInterfaces\";\r\nimport { CBSocketClient } from \"./CBSocketClient\";\r\ninterface CBSocketCallbackHolderMessageDescriptor {\r\n    key: string;\r\n    message: {\r\n        identifier: string;\r\n        inResponseToIdentifier?: string;\r\n        keepWaitingForResponses?: boolean;\r\n    };\r\n    sentAtTime: number;\r\n    messageDataHash: string;\r\n    responseDataHash?: string;\r\n    mainResponseReceived: boolean;\r\n    anyMainResponseReceived: boolean;\r\n    completionPolicy: string;\r\n    completionFunction: CBSocketMessageCompletionFunction;\r\n}\r\nexport declare class CBSocketCallbackHolder extends UIObject {\r\n    messageDescriptors: {\r\n        [x: string]: CBSocketCallbackHolderMessageDescriptor[];\r\n    };\r\n    handlers: {\r\n        [x: string]: CBSocketMessageHandlerFunction[];\r\n    };\r\n    onetimeHandlers: {\r\n        [x: string]: CBSocketMessageHandlerFunction[];\r\n    };\r\n    keysForIdentifiers: {\r\n        [x: string]: string;\r\n    };\r\n    isValid: boolean;\r\n    _storeableResponseKeys: string[];\r\n    _storedResponseHashesDictionary: {\r\n        [x: string]: {\r\n            hash: string;\r\n            validityDate: number;\r\n        };\r\n    };\r\n    _verifiedResponseHashesDictionary: {\r\n        [x: string]: boolean;\r\n    };\r\n    _socketClient: CBSocketClient;\r\n    constructor(socketClient: CBSocketClient, previousCallbackHolder?: CBSocketCallbackHolder);\r\n    triggerDisconnectHandlers(): void;\r\n    registerHandler(key: string, handlerFunction: CBSocketMessageHandlerFunction): void;\r\n    registerOnetimeHandler(key: string, handlerFunction: CBSocketMessageHandlerFunction): void;\r\n    get storedResponseHashesDictionary(): {\r\n        [x: string]: {\r\n            hash: string;\r\n            validityDate: number;\r\n        };\r\n    };\r\n    storedResponseHashObjectForKey(requestKey: string, requestDataHash: string): any;\r\n    storedResponseForKey(requestKey: string, requestDataHash: string): any;\r\n    keyForRequestKeyAndRequestDataHash(requestKey: string, requestDataHash: string): string;\r\n    storeResponse(requestKey: string, requestDataHash: string, responseMessage: CBSocketMessage<any>, responseDataHash: string): void;\r\n    private saveStoredResponseHashesDictionary;\r\n    saveInLocalStorage(key: string, object: any): void;\r\n    socketShouldSendMessage(key: string, message: CBSocketMessage<any>, completionPolicy: string, completionFunction: CBSocketMessageCompletionFunction): boolean;\r\n    static defaultMultipleMessagecompletionFunction(responseMessages: any[], callcompletionFunctions: () => void): void;\r\n    socketWillSendMultipleMessage(messageToSend: CBSocketMultipleMessage, completionFunction?: CBSocketMultipleMessagecompletionFunction): void;\r\n    socketDidReceiveMessageForKey(key: string, message: CBSocketMessage<any>, sendResponseFunction: CBSocketMessageSendResponseFunction): void;\r\n}\r\nexport {};\r\n"}}
