{"code":"import { FIRST_OR_NIL, IF, IS, IS_NIL, IS_NOT, MAKE_ID, nil, NO, RETURNER, UIObject, YES } from \"uicore-ts\";\r\nimport { CBDialogViewShower } from \"../Custom components/CBDialogViewShower\";\r\nimport { CBCore } from \"./CBCore\";\r\nimport { CBSocketCallbackHolder } from \"./CBSocketCallbackHolder\";\r\nexport function IS_SOCKET_ERROR(object) {\r\n    const result = (IS(object) && object._isCBSocketErrorMessage);\r\n    return result;\r\n}\r\nexport function IS_NOT_SOCKET_ERROR(object) {\r\n    return !IS_SOCKET_ERROR(object);\r\n}\r\nexport class CBSocketClient extends UIObject {\r\n    constructor(core) {\r\n        super();\r\n        this._socket = io();\r\n        this._isConnectionEstablished = NO;\r\n        this._collectMessagesToSendLater = NO;\r\n        this._messagesToBeSent = [];\r\n        this._subscribedKeys = {};\r\n        this._callbackHolder = new CBSocketCallbackHolder(this);\r\n        this._class = CBSocketClient;\r\n        this.superclass = UIObject;\r\n        this._core = core;\r\n        this.socket.on(\"connect\", function (socket) {\r\n            console.log(\"Socket.io connected to server. clientID = \" + socket + \", socketID = \" + socket);\r\n            var instanceIdentifier = localStorage.getItem(\"InstanceIdentifier\");\r\n            if (IS_NOT(instanceIdentifier)) {\r\n                instanceIdentifier = MAKE_ID();\r\n                localStorage.setItem(\"InstanceIdentifier\", instanceIdentifier);\r\n            }\r\n            const handshakeMessage = {\r\n                accessToken: null,\r\n                userID: this._core.userProfile._id,\r\n                inquiryAccessKey: null,\r\n                instanceIdentifier: instanceIdentifier\r\n            };\r\n            this.socket.emit(\"CBSocketHandshakeInitMessage\", {\r\n                identifier: MAKE_ID(),\r\n                messageData: handshakeMessage\r\n            });\r\n        }.bind(this));\r\n        this.socket.on(\"CBSocketHandshakeResponseMessage\", function (message) {\r\n            this._isConnectionEstablished = message.messageData.accepted;\r\n            if (!message.messageData.accepted) {\r\n                console.log(\"SocketIO connection failed.\");\r\n                CBDialogViewShower.alert(\"Failed to establish connection to server.\", function () {\r\n                });\r\n            }\r\n            else {\r\n                console.log(\"SocketIO connection handshake completed.\");\r\n                this._callbackHolder = new CBSocketCallbackHolder(this, this._callbackHolder);\r\n                core.userProfile = message.messageData.userProfile;\r\n                this.sendUnsentMessages();\r\n            }\r\n        }.bind(this));\r\n        this.socket.on(\"disconnect\", function (socket) {\r\n            console.log(\"Socket.io disconnected from server. clientID = \" + socket + \".\");\r\n            this._isConnectionEstablished = NO;\r\n            this._callbackHolder.isValid = NO;\r\n            this._callbackHolder.triggerDisconnectHandlers();\r\n        }.bind(this));\r\n        this.socket.on(\"CBPerformReconnect\", function (message) {\r\n            console.log(\"Performing socket reconnection.\");\r\n            core.reloadSocketConnection();\r\n            if (message) {\r\n                CBDialogViewShower.alert(message);\r\n            }\r\n        }.bind(this));\r\n        this._socket.on(CBSocketClient.responseMessageKey, function (message) {\r\n            this.didReceiveMessageForKey(CBSocketClient.responseMessageKey, message);\r\n        }.bind(this));\r\n        this._socket.on(CBSocketClient.multipleMessageKey, (message) => {\r\n            console.log(\"Received \" + message.messageData.length + \" messages.\");\r\n            this.didReceiveMessageForKey(CBSocketClient.multipleMessageKey, message);\r\n        });\r\n    }\r\n    get socket() {\r\n        return this._socket;\r\n    }\r\n    cancelUnsentMessages(messagesToCancel) {\r\n        this._messagesToBeSent = this._messagesToBeSent.filter(function (messageObject, index, array) {\r\n            return !messagesToCancel.contains(messageObject);\r\n        }.bind(this));\r\n    }\r\n    sendUnsentMessages(receiveResponsesTogether = NO, completion) {\r\n        if (!this._isConnectionEstablished || this._collectMessagesToSendLater) {\r\n            return;\r\n        }\r\n        const groupedMessages = [];\r\n        const didSendFunctions = [];\r\n        this._messagesToBeSent.copy().forEach(function (messageToBeSentObject, index, array) {\r\n            if (this._isConnectionEstablished) {\r\n                var message = messageToBeSentObject.message;\r\n                if (IS_NOT(message)) {\r\n                    message = \"\";\r\n                }\r\n                const identifier = MAKE_ID();\r\n                const completion = messageToBeSentObject.completion;\r\n                const messageObject = {\r\n                    messageData: message,\r\n                    identifier: identifier,\r\n                    keepWaitingForResponses: messageToBeSentObject.keepWaitingForResponses,\r\n                    inResponseToIdentifier: messageToBeSentObject.inResponseToMessage.identifier\r\n                };\r\n                const shouldSendMessage = this._callbackHolder.socketShouldSendMessage(messageToBeSentObject.key, messageObject, messageToBeSentObject.completionPolicy, completion);\r\n                if (shouldSendMessage) {\r\n                    groupedMessages.push({\r\n                        key: messageToBeSentObject.key,\r\n                        message: messageObject\r\n                    });\r\n                }\r\n                didSendFunctions.push(messageToBeSentObject.didSendFunction);\r\n            }\r\n        }.bind(this));\r\n        this._messagesToBeSent = [];\r\n        if (IS_NOT(groupedMessages.length)) {\r\n            return;\r\n        }\r\n        if (groupedMessages.length == 1) {\r\n            console.log(\"sending 1 unsent message.\");\r\n        }\r\n        else {\r\n            console.log(\"Sending \" + groupedMessages.length + \" unsent messages.\");\r\n        }\r\n        const messageObject = {\r\n            messageData: groupedMessages,\r\n            identifier: MAKE_ID(),\r\n            shouldGroupResponses: receiveResponsesTogether\r\n        };\r\n        //if (receiveResponsesTogether) {\r\n        this._callbackHolder.socketWillSendMultipleMessage(messageObject, completion);\r\n        //}\r\n        this.socket.emit(CBSocketClient.multipleMessageKey, messageObject);\r\n        didSendFunctions.forEach(function (didSendFunction, index, array) {\r\n            didSendFunction();\r\n        });\r\n    }\r\n    sendUserBoundMessageForKeyWithPolicy(key, message, completionPolicy, completion) {\r\n        this._sendMessageForKey(key, message, undefined, NO, completionPolicy, YES, nil, completion);\r\n    }\r\n    sendUserBoundMessageForKey(key, message, completion) {\r\n        this._sendMessageForKey(key, message, undefined, NO, undefined, YES, nil, completion);\r\n    }\r\n    sendMessageForKeyWithPolicy(key, message, completionPolicy, completion) {\r\n        this._sendMessageForKey(key, message, undefined, NO, completionPolicy, NO, nil, completion);\r\n    }\r\n    sendMessageForKey(key, message, completion) {\r\n        this._sendMessageForKey(key, message, undefined, NO, undefined, NO, nil, completion);\r\n    }\r\n    resultForMessageForKey(key, message, completionPolicy, isUserBound = NO) {\r\n        const result = new Promise((resolve, reject) => {\r\n            this._sendMessageForKey(key, message, undefined, NO, completionPolicy, isUserBound, nil, (responseMessage, respondWithMessage) => resolve({\r\n                responseMessage: responseMessage,\r\n                result: IF(IS_NOT_SOCKET_ERROR(responseMessage))(() => responseMessage).ELSE(RETURNER(undefined)),\r\n                errorResult: IF(IS_SOCKET_ERROR(responseMessage))(() => responseMessage).ELSE(RETURNER(undefined)),\r\n                respondWithMessage: respondWithMessage\r\n            }));\r\n        });\r\n        return result;\r\n    }\r\n    _sendMessageForKey(key, message, inResponseToMessage = {}, keepMessageConnectionOpen = NO, completionPolicy = CBSocketClient.completionPolicy.directOnly, isUserBound = NO, didSendFunction = nil, completion = nil) {\r\n        if (IS_NIL(message)) {\r\n            message = \"\";\r\n        }\r\n        if (this._isConnectionEstablished && !this._collectMessagesToSendLater) {\r\n            const identifier = MAKE_ID();\r\n            const messageObject = {\r\n                messageData: message,\r\n                identifier: identifier,\r\n                keepWaitingForResponses: keepMessageConnectionOpen,\r\n                inResponseToIdentifier: inResponseToMessage.identifier\r\n            };\r\n            const shouldSendMessage = this._callbackHolder.socketShouldSendMessage(key, messageObject, completionPolicy, completion);\r\n            if (shouldSendMessage) {\r\n                this.socket.emit(key, messageObject);\r\n            }\r\n            didSendFunction();\r\n        }\r\n        else {\r\n            this._messagesToBeSent.push({\r\n                key: key,\r\n                message: message,\r\n                inResponseToMessage: inResponseToMessage,\r\n                keepWaitingForResponses: keepMessageConnectionOpen,\r\n                completionPolicy: completionPolicy,\r\n                isBoundToUserWithID: IF(isUserBound)(RETURNER(FIRST_OR_NIL(CBCore.sharedInstance.userProfile._id)))(),\r\n                didSendFunction: didSendFunction,\r\n                completion: completion\r\n            });\r\n            return this._messagesToBeSent.lastElement;\r\n        }\r\n    }\r\n    sendMessagesAsGroup(functionToCall) {\r\n        const collectMessagesToSendLater = this._collectMessagesToSendLater;\r\n        this._collectMessagesToSendLater = YES;\r\n        var result = functionToCall();\r\n        this._collectMessagesToSendLater = collectMessagesToSendLater;\r\n        this.sendUnsentMessages();\r\n        return result;\r\n    }\r\n    sendAndReceiveMessagesAsGroup(functionToCall, completion) {\r\n        const collectMessagesToSendLater = this._collectMessagesToSendLater;\r\n        this._collectMessagesToSendLater = YES;\r\n        var result = functionToCall();\r\n        this._collectMessagesToSendLater = collectMessagesToSendLater;\r\n        this.sendUnsentMessages(YES, completion);\r\n        return result;\r\n    }\r\n    didReceiveMessageForKey(key, message) {\r\n        const sendResponseFunction = function (responseMessage, completion) {\r\n            this._sendMessageForKey(CBSocketClient.responseMessageKey, responseMessage, message, NO, undefined, NO, nil, completion);\r\n        }.bind(this);\r\n        sendResponseFunction.sendIntermediateResponse = function (updateMessage, completion) {\r\n            this._sendMessageForKey(CBSocketClient.responseMessageKey, updateMessage, message, YES, undefined, NO, nil, completion);\r\n        }.bind(this);\r\n        const sendUserBoundResponseFunction = function (responseMessage, completion) {\r\n            this._sendMessageForKey(CBSocketClient.responseMessageKey, responseMessage, message, NO, undefined, YES, nil, completion);\r\n        }.bind(this);\r\n        sendUserBoundResponseFunction.sendIntermediateResponse = function (updateMessage, completion) {\r\n            this._sendMessageForKey(CBSocketClient.responseMessageKey, updateMessage, message, YES, undefined, YES, nil, completion);\r\n        }.bind(this);\r\n        if (IS_SOCKET_ERROR(message.messageData)) {\r\n            console.log(\"CBSocketClient did receive error message.\");\r\n            console.log(message.messageData);\r\n        }\r\n        this._callbackHolder.socketDidReceiveMessageForKey(key, message, sendResponseFunction);\r\n    }\r\n    addTargetForMessagesForKeys(keys, handlerFunction) {\r\n        keys.forEach(function (key, index, array) {\r\n            this.addTargetForMessagesForKey(key, handlerFunction);\r\n        }.bind(this));\r\n    }\r\n    addTargetForMessagesForKey(key, handlerFunction) {\r\n        this._callbackHolder.registerHandler(key, handlerFunction);\r\n        if (IS_NOT(this._subscribedKeys[key])) {\r\n            this._socket.on(key, function (message) {\r\n                this.didReceiveMessageForKey(key, message);\r\n            }.bind(this));\r\n            this._subscribedKeys[key] = true;\r\n        }\r\n    }\r\n    addTargetForOneMessageForKey(key, handlerFunction) {\r\n        this._callbackHolder.registerOnetimeHandler(key, handlerFunction);\r\n        if (IS_NOT(this._subscribedKeys[key])) {\r\n            this._socket.on(key, function (message) {\r\n                this.didReceiveMessageForKey(key, message);\r\n            }.bind(this));\r\n            this._subscribedKeys[key] = true;\r\n        }\r\n    }\r\n}\r\nCBSocketClient.responseMessageKey = \"CBSocketResponseMessage\";\r\nCBSocketClient.multipleMessageKey = \"CBSocketMultipleMessage\";\r\nCBSocketClient.disconnectionMessage = {\r\n    _isCBSocketErrorMessage: YES,\r\n    messageData: \"Server disconnected\"\r\n};\r\nCBSocketClient.completionPolicy = {\r\n    \"all\": \"all\",\r\n    \"allDifferent\": \"allDifferent\",\r\n    \"first\": \"first\",\r\n    \"last\": \"last\",\r\n    \"firstAndLast\": \"firstAndLast\",\r\n    \"firstAndLastIfDifferent\": \"firstAndLastIfDifferent\",\r\n    \"directOnly\": \"directOnly\",\r\n    \"firstOnly\": \"firstOnly\",\r\n    \"storedOrFirst\": \"storedOrFirst\"\r\n};\r\nexport const SocketClient = new Proxy({ \"name\": \"SocketClient\" }, {\r\n    get(target, key) {\r\n        const result = (messageData, completionPolicy, isUserBound) => CBCore.sharedInstance.socketClient.resultForMessageForKey(key, messageData, completionPolicy, isUserBound);\r\n        return result;\r\n    }\r\n});\r\n","references":["/Users/mart/UICoreApplication/webclient/node_modules/uicore-ts/compiledScripts/index.d.ts","/Users/mart/UICoreApplication/webclient/scripts/Custom components/CBDialogViewShower.ts","/Users/mart/UICoreApplication/webclient/scripts/CBCore/CBCore.ts","/Users/mart/UICoreApplication/webclient/scripts/CBCore/CBDataInterfaces.ts","/Users/mart/UICoreApplication/webclient/scripts/CBCore/CBServerClient.ts","/Users/mart/UICoreApplication/webclient/scripts/CBCore/CBSocketCallbackHolder.ts"],"dts":{"name":"/Users/mart/UICoreApplication/webclient/node_modules/.cache/rollup-plugin-typescript2/placeholder/CBCore/CBSocketClient.d.ts","writeByteOrderMark":false,"text":"import { UIObject } from \"uicore-ts\";\r\nimport { CBCore } from \"./CBCore\";\r\nimport { CBSocketMessage, CBSocketMessageCompletionFunction, CBSocketMessageHandlerFunction, CBSocketMessageSendResponseFunction, CBSocketMultipleMessagecompletionFunction, SocketClientInterface } from \"./CBDataInterfaces\";\r\nimport { CBSocketCallbackHolder } from \"./CBSocketCallbackHolder\";\r\ndeclare interface CBSocketClientMessageToBeSent {\r\n    key: string;\r\n    message: any;\r\n    inResponseToMessage: CBSocketMessage<any>;\r\n    keepWaitingForResponses: boolean;\r\n    isBoundToUserWithID: string;\r\n    completionPolicy: string;\r\n    didSendFunction?: () => void;\r\n    completion: CBSocketMessageCompletionFunction;\r\n}\r\ndeclare interface CBSocketClientErrorMessage {\r\n    _isCBSocketErrorMessage: boolean;\r\n    messageData: any;\r\n}\r\nexport declare function IS_SOCKET_ERROR(object: any): object is CBSocketClientErrorMessage;\r\nexport declare function IS_NOT_SOCKET_ERROR(object: any): boolean;\r\nexport declare class CBSocketClient extends UIObject {\r\n    _socket: SocketIOClient.Socket;\r\n    _isConnectionEstablished: boolean;\r\n    _collectMessagesToSendLater: boolean;\r\n    _messagesToBeSent: CBSocketClientMessageToBeSent[];\r\n    static _sharedInstance: CBSocketClient;\r\n    _core: CBCore;\r\n    _subscribedKeys: {\r\n        [x: string]: boolean;\r\n    };\r\n    _callbackHolder: CBSocketCallbackHolder;\r\n    static responseMessageKey: string;\r\n    static multipleMessageKey: string;\r\n    static disconnectionMessage: CBSocketClientErrorMessage;\r\n    constructor(core: CBCore);\r\n    get socket(): SocketIOClient.Socket;\r\n    cancelUnsentMessages(messagesToCancel: CBSocketClientMessageToBeSent[]): void;\r\n    sendUnsentMessages(receiveResponsesTogether?: boolean, completion?: CBSocketMultipleMessagecompletionFunction): void;\r\n    static completionPolicy: {\r\n        all: string;\r\n        allDifferent: string;\r\n        first: string;\r\n        last: string;\r\n        firstAndLast: string;\r\n        firstAndLastIfDifferent: string;\r\n        directOnly: string;\r\n        firstOnly: string;\r\n        storedOrFirst: string;\r\n    };\r\n    sendUserBoundMessageForKeyWithPolicy(key: string, message: any, completionPolicy: string, completion?: CBSocketMessageCompletionFunction): void;\r\n    sendUserBoundMessageForKey(key: string, message: any, completion?: CBSocketMessageCompletionFunction): void;\r\n    sendMessageForKeyWithPolicy(key: string, message: any, completionPolicy: string, completion?: CBSocketMessageCompletionFunction): void;\r\n    sendMessageForKey(key: string, message: any, completion?: CBSocketMessageCompletionFunction): void;\r\n    resultForMessageForKey(key: string, message: any, completionPolicy?: string, isUserBound?: boolean): Promise<{\r\n        responseMessage: any;\r\n        result: any;\r\n        errorResult: any;\r\n        respondWithMessage: CBSocketMessageSendResponseFunction;\r\n    }>;\r\n    _sendMessageForKey(key: string, message: any, inResponseToMessage?: CBSocketMessage<any>, keepMessageConnectionOpen?: boolean, completionPolicy?: string, isUserBound?: boolean, didSendFunction?: () => void, completion?: CBSocketMessageCompletionFunction): CBSocketClientMessageToBeSent;\r\n    sendMessagesAsGroup<FunctionReturnType extends object>(functionToCall: () => FunctionReturnType): FunctionReturnType;\r\n    sendAndReceiveMessagesAsGroup<FunctionReturnType extends object>(functionToCall: () => FunctionReturnType, completion?: CBSocketMultipleMessagecompletionFunction): FunctionReturnType;\r\n    didReceiveMessageForKey(key: string, message: CBSocketMessage<any>): void;\r\n    addTargetForMessagesForKeys(keys: string[], handlerFunction: CBSocketMessageHandlerFunction): void;\r\n    addTargetForMessagesForKey(key: string, handlerFunction: CBSocketMessageHandlerFunction): void;\r\n    addTargetForOneMessageForKey(key: string, handlerFunction: CBSocketMessageHandlerFunction): void;\r\n}\r\nexport declare const SocketClient: SocketClientInterface;\r\nexport {};\r\n"}}
